# Analysis and Recommendation Methodology

This document outlines the methodologies used in the ASX Trading Analysis and Recommendation System.

## 1. Data Acquisition

*   **Source:** Historical stock prices (Open, High, Low, Close, Volume - OHLCV) and company fundamental information are sourced from Yahoo Finance using the `yfinance` Python library.
*   **ASX Tickers:** Tickers must end with `.AX` (e.g., `CBA.AX`).
*   **Frequency:** Users can select either daily (`1d`) or weekly (`1wk`) data intervals.
*   **Time Window:** Data can be fetched for a user-specified period (e.g., "1y", "5y", specific start/end dates), up to a maximum of 5 years from the current date as per project constraints. `yfinance` itself might have different "max" periods.
*   **Company Information:** Key financial metrics and company profile data (e.g., 'marketCap', 'trailingPE', 'forwardPE', 'dividendYield', 'sector', 'longBusinessSummary', 'exchange', 'currency', 'shortName') are fetched from `yfinance`'s `.info` attribute.

## 2. Data Cleansing (`data_cleanser.py`)

*   **Loading:** Price data is loaded from CSV files generated by the crawler.
*   **DateTime Conversion:** The 'Date' column is converted to `pandas.datetime` objects.
*   **Sorting:** Data is sorted by date chronologically.
*   **Missing Values (NaNs):**
    *   For OHLC columns ('Open', 'High', 'Low', 'Close'), missing values are forward-filled (`ffill`).
    *   For the 'Volume' column, missing values are first forward-filled, and any remaining NaNs (e.g., at the beginning) are filled with 0.
    *   Rows where critical OHLC values remain NaN after ffill (typically only if NaNs are at the very start of the series) are dropped.
*   **Numeric Types:** OHLCV columns are explicitly converted to numeric types.
*   **Duplicate Dates:** Rows with duplicate dates are removed, keeping the first occurrence.
*   **Adjusted Prices:** The `yfinance` library is called with `auto_adjust=True` during data crawling, meaning historical prices are automatically adjusted for dividends and stock splits. The cleansing module assumes this pre-adjusted data.
*   **Output:** A cleansed DataFrame is produced, and a report detailing the cleansing steps is generated.

## 3. Technical Analysis Indicators (`analysis_engine.py`)

The following technical indicators are calculated on the cleansed 'Close' price:

*   **Simple Moving Averages (SMAs):**
    *   **Calculation:** Standard SMAs are calculated for user-defined short-term and long-term windows.
    *   **Default Windows:**
        *   Daily data: Short = 50 periods, Long = 200 periods.
        *   Weekly data: Short = 10 periods, Long = 40 periods.
    *   **Purpose:** Identify trends and potential support/resistance levels. Crossovers and price position relative to SMAs are used in recommendation logic.
*   **Relative Strength Index (RSI):**
    *   **Calculation:** A standard 14-period RSI is calculated by default, but the window is user-configurable.
    *   **Purpose:** A momentum oscillator measuring the speed and change of price movements.
    *   **Interpretation in Recommendation:**
        *   RSI > 70: Considered overbought (cautionary for new BUY signals).
        *   RSI < 30: Considered oversold (potential opportunity).
        *   RSI > 50: Generally indicates positive momentum.
        *   RSI < 50: Generally indicates negative momentum.

## 4. Forecasting (30-Day Holding Period) (`analysis_engine.py`)

The system supports multiple models for forecasting the price approximately 30 calendar days into the future (21 trading days for daily data, 4 periods for weekly data). The user can select the desired model via the UI.

### 4.1. Simple Momentum Forecast
*   **Method:** This is a basic heuristic model.
    *   Calculates the average price change per period (daily or weekly) over a recent lookback window (typically twice the forecast horizon, e.g., ~42 trading days for a 30-calendar-day daily forecast).
    *   Projects the last close price forward by this average change multiplied by the number of trading periods equivalent to 30 calendar days.
*   **Fallback:** If data is insufficient, it uses the last single period's change or defaults to no change.
*   **Output:** Forecasted price point.

### 4.2. ARIMA (Autoregressive Integrated Moving Average) Forecast
*   **Library:** `pmdarima` (for `auto_arima`) and `statsmodels`.
*   **Methodology:**
    *   The `auto_arima` function is used to automatically find the optimal (p,d,q)(P,D,Q,m) parameters for the ARIMA model based on the AIC (Akaike Information Criterion).
    *   It internally handles stationarity testing (ADF test) and differencing (`d`, `D` parameters) to make the series stationary before fitting.
    *   Seasonality can be optionally enabled (though `m`, the seasonal period, needs careful selection based on data characteristics; UI provides a basic toggle).
*   **Output:**
    *   Forecasted price point for the end of the 30-day equivalent period.
    *   95% confidence interval for the forecast point.
    *   The determined ARIMA order (e.g., (1,1,1)).
*   **Considerations:** Requires sufficient data points (typically 20+ after differencing) for `auto_arima` to work effectively. Performance can vary based on how well the time series fits ARIMA assumptions.

### 4.3. LSTM (Long Short-Term Memory) Forecast
*   **Library:** `TensorFlow/Keras`.
*   **Methodology:**
    *   Relies on **pre-trained models**. A separate script (`lstm_model_trainer.py`) is provided for training an LSTM model for a specific ticker and saving it (along with its data scaler). Training involves:
        *   Scaling 'Close' prices (e.g., `MinMaxScaler`).
        *   Creating sequences of historical data (e.g., using last 60 periods to predict the next).
        *   A simple LSTM architecture (e.g., 2 LSTM layers, Dropout, Dense layers).
        *   Training on historical data, saving the `.keras` model and scaler.
    *   For forecasting within the application:
        *   The pre-trained model and scaler for the selected ticker are loaded.
        *   The latest sequence of data is prepared and scaled.
        *   The model iteratively predicts one step at a time for the required number of future periods (equivalent to 30 calendar days).
        *   Predictions are inverse-scaled to original price levels.
*   **Output:**
    *   Forecasted price point for the end of the 30-day equivalent period (the last point in the forecasted sequence).
    *   The full sequence of forecasted values (can be plotted).
*   **Considerations:**
    *   Performance is highly dependent on the quality of the pre-trained model, the amount of data used for training, and hyperparameter tuning.
    *   If a pre-trained model for the ticker is not found in the `models/` directory, the LSTM forecast will fail.
    *   Training LSTM models is computationally intensive and is a separate offline process.

### 4.4. Expected Return Calculation
For all forecast models, the expected return is calculated as:
`((Forecasted Price at T+30days - Last Close Price) / Last Close Price) * 100%`.

## 5. GARCH Volatility Forecasting (`analysis_engine.py`)
*   **Purpose:** To model and forecast the conditional volatility of the stock's returns, indicating expected future price fluctuations. This is separate from price forecasting.
*   **Library:** `arch`.
*   **Methodology:**
    *   Calculates logarithmic returns of the 'Close' prices (typically scaled by 100).
    *   Fits a GARCH(p,q) model (default GARCH(1,1)) to these returns. User can configure p,q via UI.
    *   Forecasts the conditional variance for the next N periods (matching the 30-day price forecast horizon).
*   **Output:** An array of forecasted conditional variances. The application then typically displays the square root (conditional standard deviation).
*   **Usage in System:** The forecasted volatility is primarily informational. It's used in the `recommender` to potentially adjust the confidence level of BUY/SELL recommendations (e.g., high forecasted volatility might reduce confidence).

## 6. Backtesting (`backtester.py`)

*   **Objective:** To evaluate the historical performance of a defined trading strategy incorporating the 30-calendar-day mandatory holding period.
*   **Default Strategy (`simple_sma_rsi_strategy`):**
    *   **Entry (BUY):**
        *   Short-term SMA > Long-term SMA.
        *   RSI < 70 (not overbought).
        *   (Implicitly, must not currently be holding the stock).
    *   **Exit Signal (SELL_SIGNAL):**
        *   (Only if currently holding stock).
        *   Short-term SMA < Long-term SMA OR RSI > 80 (very overbought, more aggressive sell signal).
*   **Execution Logic:**
    1.  Iterates through historical data.
    2.  If a BUY signal occurs and not holding, a purchase is simulated using all available capital.
    3.  The position is held for a minimum of 30 calendar days.
    4.  After the 30-day period, if a SELL_SIGNAL from the strategy occurs, the position is sold.
    5.  If the backtest period ends while still holding a position, it's valued at the last available price for final portfolio calculation.
*   **Metrics Calculated:**
    *   Initial and Final Portfolio Value.
    *   Total Return (Absolute and Percentage).
    *   Number of Trades (completed round trips).
    *   Number of Profitable Trades.
    *   Win Rate (Percentage).
    *   Average Gain Percentage (for profitable trades).
    *   Average Loss Percentage (for losing trades).

The methodologies described are based on common technical analysis techniques and simplified forecasting models. They do not guarantee future performance. Financial markets are complex and subject to various unpredictable factors. This system is intended for educational and informational purposes and should not be considered financial advice. Always conduct your own research and consult with a qualified financial advisor before making investment decisions.

The methodologies described are based on common technical analysis techniques and simplified forecasting models. They do not guarantee future performance. Financial markets are complex and subject to various unpredictable factors. This system is intended for educational and informational purposes and should not be considered financial advice. Always conduct your own research and consult with a qualified financial advisor before making investment decisions.
